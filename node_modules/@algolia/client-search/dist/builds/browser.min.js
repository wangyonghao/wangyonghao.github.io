function G(u,i,m="WithinHeaders"){let c={"x-algolia-api-key":i,"x-algolia-application-id":u};return{headers(){return m==="WithinHeaders"?c:{}},queryParameters(){return m==="WithinQueryParameters"?c:{}}}}function x({func:u,validate:i,aggregator:m,error:c,timeout:d=()=>0}){let l=e=>new Promise((r,t)=>{u(e).then(o=>(m&&m(o),i(o)?r(o):c&&c.validate(o)?t(new Error(c.message(o))):setTimeout(()=>{l(o).then(r).catch(t)},d()))).catch(o=>{t(o)})});return l()}function B(u){let i,m=`algolia-client-js-${u.key}`;function c(){return i===void 0&&(i=u.localStorage||window.localStorage),i}function d(){return JSON.parse(c().getItem(m)||"{}")}function l(r){c().setItem(m,JSON.stringify(r))}function e(){let r=u.timeToLive?u.timeToLive*1e3:null,t=d(),o=Object.fromEntries(Object.entries(t).filter(([,s])=>s.timestamp!==void 0));if(l(o),!r)return;let a=Object.fromEntries(Object.entries(o).filter(([,s])=>{let n=new Date().getTime();return!(s.timestamp+r<n)}));l(a)}return{get(r,t,o={miss:()=>Promise.resolve()}){return Promise.resolve().then(()=>(e(),d()[JSON.stringify(r)])).then(a=>Promise.all([a?a.value:t(),a!==void 0])).then(([a,s])=>Promise.all([a,s||o.miss(a)])).then(([a])=>a)},set(r,t){return Promise.resolve().then(()=>{let o=d();return o[JSON.stringify(r)]={timestamp:new Date().getTime(),value:t},c().setItem(m,JSON.stringify(o)),t})},delete(r){return Promise.resolve().then(()=>{let t=d();delete t[JSON.stringify(r)],c().setItem(m,JSON.stringify(t))})},clear(){return Promise.resolve().then(()=>{c().removeItem(m)})}}}function Z(){return{get(u,i,m={miss:()=>Promise.resolve()}){return i().then(d=>Promise.all([d,m.miss(d)])).then(([d])=>d)},set(u,i){return Promise.resolve(i)},delete(u){return Promise.resolve()},clear(){return Promise.resolve()}}}function S(u){let i=[...u.caches],m=i.shift();return m===void 0?Z():{get(c,d,l={miss:()=>Promise.resolve()}){return m.get(c,d,l).catch(()=>S({caches:i}).get(c,d,l))},set(c,d){return m.set(c,d).catch(()=>S({caches:i}).set(c,d))},delete(c){return m.delete(c).catch(()=>S({caches:i}).delete(c))},clear(){return m.clear().catch(()=>S({caches:i}).clear())}}}function T(u={serializable:!0}){let i={};return{get(m,c,d={miss:()=>Promise.resolve()}){let l=JSON.stringify(m);if(l in i)return Promise.resolve(u.serializable?JSON.parse(i[l]):i[l]);let e=c();return e.then(r=>d.miss(r)).then(()=>e)},set(m,c){return i[JSON.stringify(m)]=u.serializable?JSON.stringify(c):c,Promise.resolve(c)},delete(m){return delete i[JSON.stringify(m)],Promise.resolve()},clear(){return i={},Promise.resolve()}}}var H=2*60*1e3;function Q(u,i="up"){let m=Date.now();function c(){return i==="up"||Date.now()-m>H}function d(){return i==="timed out"&&Date.now()-m<=H}return{...u,status:i,lastUpdate:m,isUp:c,isTimedOut:d}}var L=class extends Error{name="AlgoliaError";constructor(u,i){super(u),i&&(this.name=i)}},K=class extends L{stackTrace;constructor(u,i,m){super(u,m),this.stackTrace=i}},ee=class extends K{constructor(u){super("Unreachable hosts - your application id may be incorrect. If the error persists, please reach out to the Algolia Support team: https://alg.li/support.",u,"RetryError")}},E=class extends K{status;constructor(u,i,m,c="ApiError"){super(u,m,c),this.status=i}},re=class extends L{response;constructor(u,i){super(u,"DeserializationError"),this.response=i}},te=class extends E{error;constructor(u,i,m,c){super(u,i,c,"DetailedApiError"),this.error=m}};function F(u){let i=u;for(let m=u.length-1;m>0;m--){let c=Math.floor(Math.random()*(m+1)),d=u[m];i[m]=u[c],i[c]=d}return i}function se(u,i,m){let c=oe(m),d=`${u.protocol}://${u.url}${u.port?`:${u.port}`:""}/${i.charAt(0)==="/"?i.substring(1):i}`;return c.length&&(d+=`?${c}`),d}function oe(u){return Object.keys(u).filter(i=>u[i]!==void 0).sort().map(i=>`${i}=${encodeURIComponent(Object.prototype.toString.call(u[i])==="[object Array]"?u[i].join(","):u[i]).replaceAll("+","%20")}`).join("&")}function ae(u,i){if(u.method==="GET"||u.data===void 0&&i.data===void 0)return;let m=Array.isArray(u.data)?u.data:{...u.data,...i.data};return JSON.stringify(m)}function ne(u,i,m){let c={Accept:"application/json",...u,...i,...m},d={};return Object.keys(c).forEach(l=>{let e=c[l];d[l.toLowerCase()]=e}),d}function ie(u){try{return JSON.parse(u.content)}catch(i){throw new re(i.message,u)}}function ue({content:u,status:i},m){try{let c=JSON.parse(u);return"error"in c?new te(c.message,i,c.error,m):new E(c.message,i,m)}catch{}return new E(u,i,m)}function ce({isTimedOut:u,status:i}){return!u&&~~i===0}function pe({isTimedOut:u,status:i}){return u||ce({isTimedOut:u,status:i})||~~(i/100)!==2&&~~(i/100)!==4}function me({status:u}){return~~(u/100)===2}function de(u){return u.map(i=>M(i))}function M(u){let i=u.request.headers["x-algolia-api-key"]?{"x-algolia-api-key":"*****"}:{};return{...u,request:{...u.request,headers:{...u.request.headers,...i}}}}function _({hosts:u,hostsCache:i,baseHeaders:m,baseQueryParameters:c,algoliaAgent:d,timeouts:l,requester:e,requestsCache:r,responsesCache:t}){async function o(n){let p=await Promise.all(n.map(P=>i.get(P,()=>Promise.resolve(Q(P))))),h=p.filter(P=>P.isUp()),q=p.filter(P=>P.isTimedOut()),R=[...h,...q];return{hosts:R.length>0?R:n,getTimeout(P,g){return(q.length===0&&P===0?1:q.length+3+P)*g}}}async function a(n,p,h=!0){let q=[],R=ae(n,p),f=ne(m,n.headers,p.headers),P=n.method==="GET"?{...n.data,...p.data}:{},g={...c,...n.queryParameters,...P};if(d.value&&(g["x-algolia-agent"]=d.value),p&&p.queryParameters)for(let y of Object.keys(p.queryParameters))!p.queryParameters[y]||Object.prototype.toString.call(p.queryParameters[y])==="[object Object]"?g[y]=p.queryParameters[y]:g[y]=p.queryParameters[y].toString();let b=0,v=async(y,A)=>{let O=y.pop();if(O===void 0)throw new ee(de(q));let U={...l,...p.timeouts},C={data:R,headers:f,method:n.method,url:se(O,n.path,g),connectTimeout:A(b,U.connect),responseTimeout:A(b,h?U.read:U.write)},N=D=>{let k={request:C,response:D,host:O,triesLeft:y.length};return q.push(k),k},w=await e.send(C);if(pe(w)){let D=N(w);return w.isTimedOut&&b++,console.log("Retryable failure",M(D)),await i.set(O,Q(O,w.isTimedOut?"timed out":"down")),v(y,A)}if(me(w))return ie(w);throw N(w),ue(w,q)},Y=u.filter(y=>y.accept==="readWrite"||(h?y.accept==="read":y.accept==="write")),j=await o(Y);return v([...j.hosts].reverse(),j.getTimeout)}function s(n,p={}){let h=n.useReadTransporter||n.method==="GET";if(!h)return a(n,p,h);let q=()=>a(n,p);if((p.cacheable||n.cacheable)!==!0)return q();let f={request:n,requestOptions:p,transporter:{queryParameters:c,headers:m}};return t.get(f,()=>r.get(f,()=>r.set(f,q()).then(P=>Promise.all([r.delete(f),P]),P=>Promise.all([r.delete(f),Promise.reject(P)])).then(([P,g])=>g)),{miss:P=>t.set(f,P)})}return{hostsCache:i,requester:e,timeouts:l,algoliaAgent:d,baseHeaders:m,baseQueryParameters:c,hosts:u,request:s,requestsCache:r,responsesCache:t}}function he(u){let i={value:`Algolia for JavaScript (${u})`,add(m){let c=`; ${m.segment}${m.version!==void 0?` (${m.version})`:""}`;return i.value.indexOf(c)===-1&&(i.value=`${i.value}${c}`),i}};return i}function W({algoliaAgents:u,client:i,version:m}){let c=he(m).add({segment:i,version:m});return u.forEach(d=>c.add(d)),c}var $=1e3,J=2e3,z=3e4;function V(){function u(i){return new Promise(m=>{let c=new XMLHttpRequest;c.open(i.method,i.url,!0),Object.keys(i.headers).forEach(r=>c.setRequestHeader(r,i.headers[r]));let d=(r,t)=>setTimeout(()=>{c.abort(),m({status:0,content:t,isTimedOut:!0})},r),l=d(i.connectTimeout,"Connection timeout"),e;c.onreadystatechange=()=>{c.readyState>c.OPENED&&e===void 0&&(clearTimeout(l),e=d(i.responseTimeout,"Socket timeout"))},c.onerror=()=>{c.status===0&&(clearTimeout(l),clearTimeout(e),m({content:c.responseText||"Network request failed",status:c.status,isTimedOut:!1}))},c.onload=()=>{clearTimeout(l),clearTimeout(e),m({content:c.responseText,status:c.status,isTimedOut:!1})},c.send(i.data)})}return{send:u}}var I="5.3.0";function le(u){return[{url:`${u}-dsn.algolia.net`,accept:"read",protocol:"https"},{url:`${u}.algolia.net`,accept:"write",protocol:"https"}].concat(F([{url:`${u}-1.algolianet.com`,accept:"readWrite",protocol:"https"},{url:`${u}-2.algolianet.com`,accept:"readWrite",protocol:"https"},{url:`${u}-3.algolianet.com`,accept:"readWrite",protocol:"https"}]))}function X({appId:u,apiKey:i,authMode:m,algoliaAgents:c,...d}){let l=G(u,i,m);return{transporter:_({hosts:le(u),...d,algoliaAgent:W({algoliaAgents:c,client:"Search",version:I}),baseHeaders:{"content-type":"text/plain",...l.headers(),...d.baseHeaders},baseQueryParameters:{...l.queryParameters(),...d.baseQueryParameters}}),appId:u,clearCache(){return Promise.all([this.transporter.requestsCache.clear(),this.transporter.responsesCache.clear()]).then(()=>{})},get _ua(){return this.transporter.algoliaAgent.value},addAlgoliaAgent(e,r){this.transporter.algoliaAgent.add({segment:e,version:r})},setClientApiKey({apiKey:e}){this.transporter.baseHeaders["x-algolia-api-key"]=e},waitForTask({indexName:e,taskID:r,maxRetries:t=50,timeout:o=s=>Math.min(s*200,5e3)},a){let s=0;return x({func:()=>this.getTask({indexName:e,taskID:r},a),validate:n=>n.status==="published",aggregator:()=>s+=1,error:{validate:()=>s>=t,message:()=>`The maximum number of retries exceeded. (${s}/${t})`},timeout:()=>o(s)})},waitForAppTask({taskID:e,maxRetries:r=50,timeout:t=a=>Math.min(a*200,5e3)},o){let a=0;return x({func:()=>this.getAppTask({taskID:e},o),validate:s=>s.status==="published",aggregator:()=>a+=1,error:{validate:()=>a>=r,message:()=>`The maximum number of retries exceeded. (${a}/${r})`},timeout:()=>t(a)})},waitForApiKey({operation:e,key:r,apiKey:t,maxRetries:o=50,timeout:a=n=>Math.min(n*200,5e3)},s){let n=0,p={aggregator:()=>n+=1,error:{validate:()=>n>=o,message:()=>`The maximum number of retries exceeded. (${n}/${o})`},timeout:()=>a(n)};if(e==="update"){if(!t)throw new Error("`apiKey` is required when waiting for an `update` operation.");return x({...p,func:()=>this.getApiKey({key:r},s),validate:h=>{for(let q of Object.keys(t)){let R=t[q],f=h[q];if(Array.isArray(R)&&Array.isArray(f)){if(R.length!==f.length||R.some((P,g)=>P!==f[g]))return!1}else if(R!==f)return!1}return!0}})}return x({...p,func:()=>this.getApiKey({key:r},s).catch(h=>{if(h.status!==404)throw h}),validate:h=>e==="add"?h!==void 0:h===void 0})},browseObjects({indexName:e,browseParams:r,...t},o){return x({func:a=>this.browse({indexName:e,browseParams:{cursor:a?a.cursor:void 0,...r}},o),validate:a=>a.cursor===void 0,...t})},browseRules({indexName:e,searchRulesParams:r,...t},o){let a={hitsPerPage:1e3,...r};return x({func:s=>this.searchRules({indexName:e,searchRulesParams:{...a,page:s?s.page+1:a.page||0}},o),validate:s=>s.nbHits<a.hitsPerPage,...t})},browseSynonyms({indexName:e,searchSynonymsParams:r,...t},o){let a={page:0,...r,hitsPerPage:1e3};return x({func:s=>{let n=this.searchSynonyms({indexName:e,searchSynonymsParams:{...a,page:a.page}},o);return a.page+=1,n},validate:s=>s.nbHits<a.hitsPerPage,...t})},async chunkedBatch({indexName:e,objects:r,action:t="addObject",waitForTasks:o,batchSize:a=1e3},s){let n=[],p=[],h=r.entries();for(let[q,R]of h)n.push({action:t,body:R}),(n.length===a||q===r.length-1)&&(p.push(await this.batch({indexName:e,batchWriteParams:{requests:n}},s)),n=[]);if(o)for(let q of p)await this.waitForTask({indexName:e,taskID:q.taskID});return p},async saveObjects({indexName:e,objects:r},t){return await this.chunkedBatch({indexName:e,objects:r,action:"addObject"},t)},async deleteObjects({indexName:e,objectIDs:r},t){return await this.chunkedBatch({indexName:e,objects:r.map(o=>({objectID:o})),action:"deleteObject"},t)},async partialUpdateObjects({indexName:e,objects:r,createIfNotExists:t},o){return await this.chunkedBatch({indexName:e,objects:r,action:t?"partialUpdateObject":"partialUpdateObjectNoCreate"},o)},async replaceAllObjects({indexName:e,objects:r,batchSize:t},o){let a=Math.floor(Math.random()*1e6)+1e5,s=`${e}_tmp_${a}`,n=await this.operationIndex({indexName:e,operationIndexParams:{operation:"copy",destination:s,scope:["settings","rules","synonyms"]}},o),p=await this.chunkedBatch({indexName:s,objects:r,waitForTasks:!0,batchSize:t},o);await this.waitForTask({indexName:s,taskID:n.taskID}),n=await this.operationIndex({indexName:e,operationIndexParams:{operation:"copy",destination:s,scope:["settings","rules","synonyms"]}},o),await this.waitForTask({indexName:s,taskID:n.taskID});let h=await this.operationIndex({indexName:s,operationIndexParams:{operation:"move",destination:e}},o);return await this.waitForTask({indexName:s,taskID:h.taskID}),{copyOperationResponse:n,batchResponses:p,moveOperationResponse:h}},async indexExists({indexName:e}){try{await this.getSettings({indexName:e})}catch(r){if(r instanceof E&&r.status===404)return!1;throw r}return!0},searchForHits(e,r){return this.search(e,r)},searchForFacets(e,r){return this.search(e,r)},addApiKey(e,r){if(!e)throw new Error("Parameter `apiKey` is required when calling `addApiKey`.");if(!e.acl)throw new Error("Parameter `apiKey.acl` is required when calling `addApiKey`.");let s={method:"POST",path:"/1/keys",queryParameters:{},headers:{},data:e};return this.transporter.request(s,r)},addOrUpdateObject({indexName:e,objectID:r,body:t},o){if(!e)throw new Error("Parameter `indexName` is required when calling `addOrUpdateObject`.");if(!r)throw new Error("Parameter `objectID` is required when calling `addOrUpdateObject`.");if(!t)throw new Error("Parameter `body` is required when calling `addOrUpdateObject`.");let p={method:"PUT",path:"/1/indexes/{indexName}/{objectID}".replace("{indexName}",encodeURIComponent(e)).replace("{objectID}",encodeURIComponent(r)),queryParameters:{},headers:{},data:t};return this.transporter.request(p,o)},appendSource(e,r){if(!e)throw new Error("Parameter `source` is required when calling `appendSource`.");if(!e.source)throw new Error("Parameter `source.source` is required when calling `appendSource`.");let s={method:"POST",path:"/1/security/sources/append",queryParameters:{},headers:{},data:e};return this.transporter.request(s,r)},assignUserId({xAlgoliaUserID:e,assignUserIdParams:r},t){if(!e)throw new Error("Parameter `xAlgoliaUserID` is required when calling `assignUserId`.");if(!r)throw new Error("Parameter `assignUserIdParams` is required when calling `assignUserId`.");if(!r.cluster)throw new Error("Parameter `assignUserIdParams.cluster` is required when calling `assignUserId`.");let o="/1/clusters/mapping",a={},s={};e!==void 0&&(a["X-Algolia-User-ID"]=e.toString());let n={method:"POST",path:o,queryParameters:s,headers:a,data:r};return this.transporter.request(n,t)},batch({indexName:e,batchWriteParams:r},t){if(!e)throw new Error("Parameter `indexName` is required when calling `batch`.");if(!r)throw new Error("Parameter `batchWriteParams` is required when calling `batch`.");if(!r.requests)throw new Error("Parameter `batchWriteParams.requests` is required when calling `batch`.");let n={method:"POST",path:"/1/indexes/{indexName}/batch".replace("{indexName}",encodeURIComponent(e)),queryParameters:{},headers:{},data:r};return this.transporter.request(n,t)},batchAssignUserIds({xAlgoliaUserID:e,batchAssignUserIdsParams:r},t){if(!e)throw new Error("Parameter `xAlgoliaUserID` is required when calling `batchAssignUserIds`.");if(!r)throw new Error("Parameter `batchAssignUserIdsParams` is required when calling `batchAssignUserIds`.");if(!r.cluster)throw new Error("Parameter `batchAssignUserIdsParams.cluster` is required when calling `batchAssignUserIds`.");if(!r.users)throw new Error("Parameter `batchAssignUserIdsParams.users` is required when calling `batchAssignUserIds`.");let o="/1/clusters/mapping/batch",a={},s={};e!==void 0&&(a["X-Algolia-User-ID"]=e.toString());let n={method:"POST",path:o,queryParameters:s,headers:a,data:r};return this.transporter.request(n,t)},batchDictionaryEntries({dictionaryName:e,batchDictionaryEntriesParams:r},t){if(!e)throw new Error("Parameter `dictionaryName` is required when calling `batchDictionaryEntries`.");if(!r)throw new Error("Parameter `batchDictionaryEntriesParams` is required when calling `batchDictionaryEntries`.");if(!r.requests)throw new Error("Parameter `batchDictionaryEntriesParams.requests` is required when calling `batchDictionaryEntries`.");let n={method:"POST",path:"/1/dictionaries/{dictionaryName}/batch".replace("{dictionaryName}",encodeURIComponent(e)),queryParameters:{},headers:{},data:r};return this.transporter.request(n,t)},browse({indexName:e,browseParams:r},t){if(!e)throw new Error("Parameter `indexName` is required when calling `browse`.");let n={method:"POST",path:"/1/indexes/{indexName}/browse".replace("{indexName}",encodeURIComponent(e)),queryParameters:{},headers:{},data:r||{}};return this.transporter.request(n,t)},clearObjects({indexName:e},r){if(!e)throw new Error("Parameter `indexName` is required when calling `clearObjects`.");let s={method:"POST",path:"/1/indexes/{indexName}/clear".replace("{indexName}",encodeURIComponent(e)),queryParameters:{},headers:{}};return this.transporter.request(s,r)},clearRules({indexName:e,forwardToReplicas:r},t){if(!e)throw new Error("Parameter `indexName` is required when calling `clearRules`.");let o="/1/indexes/{indexName}/rules/clear".replace("{indexName}",encodeURIComponent(e)),a={},s={};r!==void 0&&(s.forwardToReplicas=r.toString());let n={method:"POST",path:o,queryParameters:s,headers:a};return this.transporter.request(n,t)},clearSynonyms({indexName:e,forwardToReplicas:r},t){if(!e)throw new Error("Parameter `indexName` is required when calling `clearSynonyms`.");let o="/1/indexes/{indexName}/synonyms/clear".replace("{indexName}",encodeURIComponent(e)),a={},s={};r!==void 0&&(s.forwardToReplicas=r.toString());let n={method:"POST",path:o,queryParameters:s,headers:a};return this.transporter.request(n,t)},customDelete({path:e,parameters:r},t){if(!e)throw new Error("Parameter `path` is required when calling `customDelete`.");let n={method:"DELETE",path:"/{path}".replace("{path}",e),queryParameters:r||{},headers:{}};return this.transporter.request(n,t)},customGet({path:e,parameters:r},t){if(!e)throw new Error("Parameter `path` is required when calling `customGet`.");let n={method:"GET",path:"/{path}".replace("{path}",e),queryParameters:r||{},headers:{}};return this.transporter.request(n,t)},customPost({path:e,parameters:r,body:t},o){if(!e)throw new Error("Parameter `path` is required when calling `customPost`.");let p={method:"POST",path:"/{path}".replace("{path}",e),queryParameters:r||{},headers:{},data:t||{}};return this.transporter.request(p,o)},customPut({path:e,parameters:r,body:t},o){if(!e)throw new Error("Parameter `path` is required when calling `customPut`.");let p={method:"PUT",path:"/{path}".replace("{path}",e),queryParameters:r||{},headers:{},data:t||{}};return this.transporter.request(p,o)},deleteApiKey({key:e},r){if(!e)throw new Error("Parameter `key` is required when calling `deleteApiKey`.");let s={method:"DELETE",path:"/1/keys/{key}".replace("{key}",encodeURIComponent(e)),queryParameters:{},headers:{}};return this.transporter.request(s,r)},deleteBy({indexName:e,deleteByParams:r},t){if(!e)throw new Error("Parameter `indexName` is required when calling `deleteBy`.");if(!r)throw new Error("Parameter `deleteByParams` is required when calling `deleteBy`.");let n={method:"POST",path:"/1/indexes/{indexName}/deleteByQuery".replace("{indexName}",encodeURIComponent(e)),queryParameters:{},headers:{},data:r};return this.transporter.request(n,t)},deleteIndex({indexName:e},r){if(!e)throw new Error("Parameter `indexName` is required when calling `deleteIndex`.");let s={method:"DELETE",path:"/1/indexes/{indexName}".replace("{indexName}",encodeURIComponent(e)),queryParameters:{},headers:{}};return this.transporter.request(s,r)},deleteObject({indexName:e,objectID:r},t){if(!e)throw new Error("Parameter `indexName` is required when calling `deleteObject`.");if(!r)throw new Error("Parameter `objectID` is required when calling `deleteObject`.");let n={method:"DELETE",path:"/1/indexes/{indexName}/{objectID}".replace("{indexName}",encodeURIComponent(e)).replace("{objectID}",encodeURIComponent(r)),queryParameters:{},headers:{}};return this.transporter.request(n,t)},deleteRule({indexName:e,objectID:r,forwardToReplicas:t},o){if(!e)throw new Error("Parameter `indexName` is required when calling `deleteRule`.");if(!r)throw new Error("Parameter `objectID` is required when calling `deleteRule`.");let a="/1/indexes/{indexName}/rules/{objectID}".replace("{indexName}",encodeURIComponent(e)).replace("{objectID}",encodeURIComponent(r)),s={},n={};t!==void 0&&(n.forwardToReplicas=t.toString());let p={method:"DELETE",path:a,queryParameters:n,headers:s};return this.transporter.request(p,o)},deleteSource({source:e},r){if(!e)throw new Error("Parameter `source` is required when calling `deleteSource`.");let s={method:"DELETE",path:"/1/security/sources/{source}".replace("{source}",encodeURIComponent(e)),queryParameters:{},headers:{}};return this.transporter.request(s,r)},deleteSynonym({indexName:e,objectID:r,forwardToReplicas:t},o){if(!e)throw new Error("Parameter `indexName` is required when calling `deleteSynonym`.");if(!r)throw new Error("Parameter `objectID` is required when calling `deleteSynonym`.");let a="/1/indexes/{indexName}/synonyms/{objectID}".replace("{indexName}",encodeURIComponent(e)).replace("{objectID}",encodeURIComponent(r)),s={},n={};t!==void 0&&(n.forwardToReplicas=t.toString());let p={method:"DELETE",path:a,queryParameters:n,headers:s};return this.transporter.request(p,o)},getApiKey({key:e},r){if(!e)throw new Error("Parameter `key` is required when calling `getApiKey`.");let s={method:"GET",path:"/1/keys/{key}".replace("{key}",encodeURIComponent(e)),queryParameters:{},headers:{}};return this.transporter.request(s,r)},getAppTask({taskID:e},r){if(!e)throw new Error("Parameter `taskID` is required when calling `getAppTask`.");let s={method:"GET",path:"/1/task/{taskID}".replace("{taskID}",encodeURIComponent(e)),queryParameters:{},headers:{}};return this.transporter.request(s,r)},getDictionaryLanguages(e){let a={method:"GET",path:"/1/dictionaries/*/languages",queryParameters:{},headers:{}};return this.transporter.request(a,e)},getDictionarySettings(e){let a={method:"GET",path:"/1/dictionaries/*/settings",queryParameters:{},headers:{}};return this.transporter.request(a,e)},getLogs({offset:e,length:r,indexName:t,type:o}={},a=void 0){let s="/1/logs",n={},p={};e!==void 0&&(p.offset=e.toString()),r!==void 0&&(p.length=r.toString()),t!==void 0&&(p.indexName=t.toString()),o!==void 0&&(p.type=o.toString());let h={method:"GET",path:s,queryParameters:p,headers:n};return this.transporter.request(h,a)},getObject({indexName:e,objectID:r,attributesToRetrieve:t},o){if(!e)throw new Error("Parameter `indexName` is required when calling `getObject`.");if(!r)throw new Error("Parameter `objectID` is required when calling `getObject`.");let a="/1/indexes/{indexName}/{objectID}".replace("{indexName}",encodeURIComponent(e)).replace("{objectID}",encodeURIComponent(r)),s={},n={};t!==void 0&&(n.attributesToRetrieve=t.toString());let p={method:"GET",path:a,queryParameters:n,headers:s};return this.transporter.request(p,o)},getObjects(e,r){if(!e)throw new Error("Parameter `getObjectsParams` is required when calling `getObjects`.");if(!e.requests)throw new Error("Parameter `getObjectsParams.requests` is required when calling `getObjects`.");let s={method:"POST",path:"/1/indexes/*/objects",queryParameters:{},headers:{},data:e,useReadTransporter:!0,cacheable:!0};return this.transporter.request(s,r)},getRule({indexName:e,objectID:r},t){if(!e)throw new Error("Parameter `indexName` is required when calling `getRule`.");if(!r)throw new Error("Parameter `objectID` is required when calling `getRule`.");let n={method:"GET",path:"/1/indexes/{indexName}/rules/{objectID}".replace("{indexName}",encodeURIComponent(e)).replace("{objectID}",encodeURIComponent(r)),queryParameters:{},headers:{}};return this.transporter.request(n,t)},getSettings({indexName:e},r){if(!e)throw new Error("Parameter `indexName` is required when calling `getSettings`.");let s={method:"GET",path:"/1/indexes/{indexName}/settings".replace("{indexName}",encodeURIComponent(e)),queryParameters:{},headers:{}};return this.transporter.request(s,r)},getSources(e){let a={method:"GET",path:"/1/security/sources",queryParameters:{},headers:{}};return this.transporter.request(a,e)},getSynonym({indexName:e,objectID:r},t){if(!e)throw new Error("Parameter `indexName` is required when calling `getSynonym`.");if(!r)throw new Error("Parameter `objectID` is required when calling `getSynonym`.");let n={method:"GET",path:"/1/indexes/{indexName}/synonyms/{objectID}".replace("{indexName}",encodeURIComponent(e)).replace("{objectID}",encodeURIComponent(r)),queryParameters:{},headers:{}};return this.transporter.request(n,t)},getTask({indexName:e,taskID:r},t){if(!e)throw new Error("Parameter `indexName` is required when calling `getTask`.");if(!r)throw new Error("Parameter `taskID` is required when calling `getTask`.");let n={method:"GET",path:"/1/indexes/{indexName}/task/{taskID}".replace("{indexName}",encodeURIComponent(e)).replace("{taskID}",encodeURIComponent(r)),queryParameters:{},headers:{}};return this.transporter.request(n,t)},getTopUserIds(e){let a={method:"GET",path:"/1/clusters/mapping/top",queryParameters:{},headers:{}};return this.transporter.request(a,e)},getUserId({userID:e},r){if(!e)throw new Error("Parameter `userID` is required when calling `getUserId`.");let s={method:"GET",path:"/1/clusters/mapping/{userID}".replace("{userID}",encodeURIComponent(e)),queryParameters:{},headers:{}};return this.transporter.request(s,r)},hasPendingMappings({getClusters:e}={},r=void 0){let t="/1/clusters/mapping/pending",o={},a={};e!==void 0&&(a.getClusters=e.toString());let s={method:"GET",path:t,queryParameters:a,headers:o};return this.transporter.request(s,r)},listApiKeys(e){let a={method:"GET",path:"/1/keys",queryParameters:{},headers:{}};return this.transporter.request(a,e)},listClusters(e){let a={method:"GET",path:"/1/clusters",queryParameters:{},headers:{}};return this.transporter.request(a,e)},listIndices({page:e,hitsPerPage:r}={},t=void 0){let o="/1/indexes",a={},s={};e!==void 0&&(s.page=e.toString()),r!==void 0&&(s.hitsPerPage=r.toString());let n={method:"GET",path:o,queryParameters:s,headers:a};return this.transporter.request(n,t)},listUserIds({page:e,hitsPerPage:r}={},t=void 0){let o="/1/clusters/mapping",a={},s={};e!==void 0&&(s.page=e.toString()),r!==void 0&&(s.hitsPerPage=r.toString());let n={method:"GET",path:o,queryParameters:s,headers:a};return this.transporter.request(n,t)},multipleBatch(e,r){if(!e)throw new Error("Parameter `batchParams` is required when calling `multipleBatch`.");if(!e.requests)throw new Error("Parameter `batchParams.requests` is required when calling `multipleBatch`.");let s={method:"POST",path:"/1/indexes/*/batch",queryParameters:{},headers:{},data:e};return this.transporter.request(s,r)},operationIndex({indexName:e,operationIndexParams:r},t){if(!e)throw new Error("Parameter `indexName` is required when calling `operationIndex`.");if(!r)throw new Error("Parameter `operationIndexParams` is required when calling `operationIndex`.");if(!r.operation)throw new Error("Parameter `operationIndexParams.operation` is required when calling `operationIndex`.");if(!r.destination)throw new Error("Parameter `operationIndexParams.destination` is required when calling `operationIndex`.");let n={method:"POST",path:"/1/indexes/{indexName}/operation".replace("{indexName}",encodeURIComponent(e)),queryParameters:{},headers:{},data:r};return this.transporter.request(n,t)},partialUpdateObject({indexName:e,objectID:r,attributesToUpdate:t,createIfNotExists:o},a){if(!e)throw new Error("Parameter `indexName` is required when calling `partialUpdateObject`.");if(!r)throw new Error("Parameter `objectID` is required when calling `partialUpdateObject`.");if(!t)throw new Error("Parameter `attributesToUpdate` is required when calling `partialUpdateObject`.");let s="/1/indexes/{indexName}/{objectID}/partial".replace("{indexName}",encodeURIComponent(e)).replace("{objectID}",encodeURIComponent(r)),n={},p={};o!==void 0&&(p.createIfNotExists=o.toString());let h={method:"POST",path:s,queryParameters:p,headers:n,data:t};return this.transporter.request(h,a)},removeUserId({userID:e},r){if(!e)throw new Error("Parameter `userID` is required when calling `removeUserId`.");let s={method:"DELETE",path:"/1/clusters/mapping/{userID}".replace("{userID}",encodeURIComponent(e)),queryParameters:{},headers:{}};return this.transporter.request(s,r)},replaceSources({source:e},r){if(!e)throw new Error("Parameter `source` is required when calling `replaceSources`.");let s={method:"PUT",path:"/1/security/sources",queryParameters:{},headers:{},data:e};return this.transporter.request(s,r)},restoreApiKey({key:e},r){if(!e)throw new Error("Parameter `key` is required when calling `restoreApiKey`.");let s={method:"POST",path:"/1/keys/{key}/restore".replace("{key}",encodeURIComponent(e)),queryParameters:{},headers:{}};return this.transporter.request(s,r)},saveObject({indexName:e,body:r},t){if(!e)throw new Error("Parameter `indexName` is required when calling `saveObject`.");if(!r)throw new Error("Parameter `body` is required when calling `saveObject`.");let n={method:"POST",path:"/1/indexes/{indexName}".replace("{indexName}",encodeURIComponent(e)),queryParameters:{},headers:{},data:r};return this.transporter.request(n,t)},saveRule({indexName:e,objectID:r,rule:t,forwardToReplicas:o},a){if(!e)throw new Error("Parameter `indexName` is required when calling `saveRule`.");if(!r)throw new Error("Parameter `objectID` is required when calling `saveRule`.");if(!t)throw new Error("Parameter `rule` is required when calling `saveRule`.");if(!t.objectID)throw new Error("Parameter `rule.objectID` is required when calling `saveRule`.");let s="/1/indexes/{indexName}/rules/{objectID}".replace("{indexName}",encodeURIComponent(e)).replace("{objectID}",encodeURIComponent(r)),n={},p={};o!==void 0&&(p.forwardToReplicas=o.toString());let h={method:"PUT",path:s,queryParameters:p,headers:n,data:t};return this.transporter.request(h,a)},saveRules({indexName:e,rules:r,forwardToReplicas:t,clearExistingRules:o},a){if(!e)throw new Error("Parameter `indexName` is required when calling `saveRules`.");if(!r)throw new Error("Parameter `rules` is required when calling `saveRules`.");let s="/1/indexes/{indexName}/rules/batch".replace("{indexName}",encodeURIComponent(e)),n={},p={};t!==void 0&&(p.forwardToReplicas=t.toString()),o!==void 0&&(p.clearExistingRules=o.toString());let h={method:"POST",path:s,queryParameters:p,headers:n,data:r};return this.transporter.request(h,a)},saveSynonym({indexName:e,objectID:r,synonymHit:t,forwardToReplicas:o},a){if(!e)throw new Error("Parameter `indexName` is required when calling `saveSynonym`.");if(!r)throw new Error("Parameter `objectID` is required when calling `saveSynonym`.");if(!t)throw new Error("Parameter `synonymHit` is required when calling `saveSynonym`.");if(!t.objectID)throw new Error("Parameter `synonymHit.objectID` is required when calling `saveSynonym`.");if(!t.type)throw new Error("Parameter `synonymHit.type` is required when calling `saveSynonym`.");let s="/1/indexes/{indexName}/synonyms/{objectID}".replace("{indexName}",encodeURIComponent(e)).replace("{objectID}",encodeURIComponent(r)),n={},p={};o!==void 0&&(p.forwardToReplicas=o.toString());let h={method:"PUT",path:s,queryParameters:p,headers:n,data:t};return this.transporter.request(h,a)},saveSynonyms({indexName:e,synonymHit:r,forwardToReplicas:t,replaceExistingSynonyms:o},a){if(!e)throw new Error("Parameter `indexName` is required when calling `saveSynonyms`.");if(!r)throw new Error("Parameter `synonymHit` is required when calling `saveSynonyms`.");let s="/1/indexes/{indexName}/synonyms/batch".replace("{indexName}",encodeURIComponent(e)),n={},p={};t!==void 0&&(p.forwardToReplicas=t.toString()),o!==void 0&&(p.replaceExistingSynonyms=o.toString());let h={method:"POST",path:s,queryParameters:p,headers:n,data:r};return this.transporter.request(h,a)},search(e,r){if(e&&Array.isArray(e)&&(e={requests:e.map(({params:p,...h})=>h.type==="facet"?{...h,...p,type:"facet"}:{...h,...p,facet:void 0,maxFacetHits:void 0,facetQuery:void 0})}),!e)throw new Error("Parameter `searchMethodParams` is required when calling `search`.");if(!e.requests)throw new Error("Parameter `searchMethodParams.requests` is required when calling `search`.");let s={method:"POST",path:"/1/indexes/*/queries",queryParameters:{},headers:{},data:e,useReadTransporter:!0,cacheable:!0};return this.transporter.request(s,r)},searchDictionaryEntries({dictionaryName:e,searchDictionaryEntriesParams:r},t){if(!e)throw new Error("Parameter `dictionaryName` is required when calling `searchDictionaryEntries`.");if(!r)throw new Error("Parameter `searchDictionaryEntriesParams` is required when calling `searchDictionaryEntries`.");if(!r.query)throw new Error("Parameter `searchDictionaryEntriesParams.query` is required when calling `searchDictionaryEntries`.");let n={method:"POST",path:"/1/dictionaries/{dictionaryName}/search".replace("{dictionaryName}",encodeURIComponent(e)),queryParameters:{},headers:{},data:r,useReadTransporter:!0,cacheable:!0};return this.transporter.request(n,t)},searchForFacetValues({indexName:e,facetName:r,searchForFacetValuesRequest:t},o){if(!e)throw new Error("Parameter `indexName` is required when calling `searchForFacetValues`.");if(!r)throw new Error("Parameter `facetName` is required when calling `searchForFacetValues`.");let p={method:"POST",path:"/1/indexes/{indexName}/facets/{facetName}/query".replace("{indexName}",encodeURIComponent(e)).replace("{facetName}",encodeURIComponent(r)),queryParameters:{},headers:{},data:t||{},useReadTransporter:!0,cacheable:!0};return this.transporter.request(p,o)},searchRules({indexName:e,searchRulesParams:r},t){if(!e)throw new Error("Parameter `indexName` is required when calling `searchRules`.");let n={method:"POST",path:"/1/indexes/{indexName}/rules/search".replace("{indexName}",encodeURIComponent(e)),queryParameters:{},headers:{},data:r||{},useReadTransporter:!0,cacheable:!0};return this.transporter.request(n,t)},searchSingleIndex({indexName:e,searchParams:r},t){if(!e)throw new Error("Parameter `indexName` is required when calling `searchSingleIndex`.");let n={method:"POST",path:"/1/indexes/{indexName}/query".replace("{indexName}",encodeURIComponent(e)),queryParameters:{},headers:{},data:r||{},useReadTransporter:!0,cacheable:!0};return this.transporter.request(n,t)},searchSynonyms({indexName:e,searchSynonymsParams:r},t){if(!e)throw new Error("Parameter `indexName` is required when calling `searchSynonyms`.");let n={method:"POST",path:"/1/indexes/{indexName}/synonyms/search".replace("{indexName}",encodeURIComponent(e)),queryParameters:{},headers:{},data:r||{},useReadTransporter:!0,cacheable:!0};return this.transporter.request(n,t)},searchUserIds(e,r){if(!e)throw new Error("Parameter `searchUserIdsParams` is required when calling `searchUserIds`.");if(!e.query)throw new Error("Parameter `searchUserIdsParams.query` is required when calling `searchUserIds`.");let s={method:"POST",path:"/1/clusters/mapping/search",queryParameters:{},headers:{},data:e,useReadTransporter:!0,cacheable:!0};return this.transporter.request(s,r)},setDictionarySettings(e,r){if(!e)throw new Error("Parameter `dictionarySettingsParams` is required when calling `setDictionarySettings`.");if(!e.disableStandardEntries)throw new Error("Parameter `dictionarySettingsParams.disableStandardEntries` is required when calling `setDictionarySettings`.");let s={method:"PUT",path:"/1/dictionaries/*/settings",queryParameters:{},headers:{},data:e};return this.transporter.request(s,r)},setSettings({indexName:e,indexSettings:r,forwardToReplicas:t},o){if(!e)throw new Error("Parameter `indexName` is required when calling `setSettings`.");if(!r)throw new Error("Parameter `indexSettings` is required when calling `setSettings`.");let a="/1/indexes/{indexName}/settings".replace("{indexName}",encodeURIComponent(e)),s={},n={};t!==void 0&&(n.forwardToReplicas=t.toString());let p={method:"PUT",path:a,queryParameters:n,headers:s,data:r};return this.transporter.request(p,o)},updateApiKey({key:e,apiKey:r},t){if(!e)throw new Error("Parameter `key` is required when calling `updateApiKey`.");if(!r)throw new Error("Parameter `apiKey` is required when calling `updateApiKey`.");if(!r.acl)throw new Error("Parameter `apiKey.acl` is required when calling `updateApiKey`.");let n={method:"PUT",path:"/1/keys/{key}".replace("{key}",encodeURIComponent(e)),queryParameters:{},headers:{},data:r};return this.transporter.request(n,t)}}}function Fs(u,i,m){if(!u||typeof u!="string")throw new Error("`appId` is missing.");if(!i||typeof i!="string")throw new Error("`apiKey` is missing.");return X({appId:u,apiKey:i,timeouts:{connect:$,read:J,write:z},requester:V(),algoliaAgents:[{segment:"Browser"}],authMode:"WithinQueryParameters",responsesCache:T(),requestsCache:T({serializable:!1}),hostsCache:S({caches:[B({key:`${I}-${u}`}),T()]}),...m})}export{I as apiClientVersion,Fs as searchClient};
//# sourceMappingURL=browser.min.js.map