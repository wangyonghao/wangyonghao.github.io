# 单例模式（Singleton Pattern)

[TOC]

## 介绍

单例模式属于创建型模式的一种。在应用这个模式时，单例对象的[类](https://zh.wikipedia.org/wiki/类_(计算机科学))必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局[对象](https://zh.wikipedia.org/wiki/对象)，这样有利于我们协调系统整体的行为。比如在某个[服务器](https://zh.wikipedia.org/wiki/服务器)程序中，该服务器的配置信息存放在一个[文件](https://zh.wikipedia.org/wiki/文件)中，这些配置数据由一个单例对象统一读取，然后服务[进程](https://zh.wikipedia.org/wiki/进程)中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。

### 意图

确保一个类仅有一个实例，并为它提供一个全局访问点。

### 优点

1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。
2. 避免对资源的多重占用。

### 缺点

没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。



## 实现

实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；

### 懒汉式（Hungry)

第一次调用才初始化，这种方式具备很好的 lazy loading，避免内存浪费。在多线程场景下，必须加锁synchronized来保证单例，但加锁会影响效率。

### 饿汉式（Lazy)

类加载时就初始化。在类装载时就实例化，容易产生垃圾对象。由于没有加锁，效率会提高，

### 双检锁/双重校验锁（DCL，即 double-checked locking）

采用双锁机制，安全且在多线程情况下能保持高性能

### 登记式/静态内部类（Static)

通过对静态域使用延迟初始化，能达到双检锁方式一样的功效，但实现更简单。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。

### 枚举式(Enumeration)

这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。
这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。
不能通过 reflection attack 来调用私有构造方法。

### 应用实例

- Spring Bean的设计



**经验之谈：**一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。

## 参考资料

- [单例模式](https://www.ibm.com/developerworks/cn/java/j-lo-Singleton/index.html?ca=drs-) - IBM Developer
- 《设计模式》

